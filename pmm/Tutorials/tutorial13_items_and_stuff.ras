program Tutorial13;
var  
	mainChar: IncBin("charsets/charset_regular_tutorial13.bin","$2800");

	levelChar: IncBin("charsets/tutorial13.bin","$3000");


	levels: IncBin("levels/tutorial13.flf", "$3800");
//	music1 : incsid("fliptape3.sid");
	sprite0data : incbin("sprites/fastfood.bin", "$8800");
	m_posx, m_posy : byte; // current level position in grid
 	i, redraw, j,k: byte;  // i is temp, redraw states that the map should be redrawn
	
	sprite1_counter, tmp2,val : byte; // sprite1_counter shifts between sprite animations 
	spritex, tmp : integer; // Sprite positions and temp integer
	spritey, frameCounter : byte;

	intro_image_color: IncBin("images/lemonspawn_color.bin", "$9000");
	intro_image_data: IncBin("images/lemonspawn_data.bin", "$A000");

	current_background : byte;

	entity_sprites : array[8] of byte = (
		$91, $90, $93, $94, $95, $96, $97, $98, $92);

    fade : array [16] of byte = (11,6,6,12,4,14,15,1,1,15,14,4,12,6,6,11); 

	prev_dx, prev_dy : byte;


	// Entities
	no_entities : byte;
	entity_pos_x : array[8] of byte;
	entity_pos_y : array[8] of byte;
	entity_curpos_x : array[8] of byte;
	entity_curpos_y : array[8] of byte;
	entity_dd_x : array[8] of byte;
	entity_dd_y : array[8] of byte;
	entity_pos_spread : array[8] of byte;
	entity_type : array[8] of byte;
	entity_color : array[8] of byte;

	entity_framecounter_x : array[8] of byte;
	entity_framecounter_y : array[8] of byte;

	entity_framecounter_maxx : array[8] of byte;
	entity_framecounter_maxy : array[8] of byte;


	player_health : byte;
	bullet_count : byte;

	bullet_x : byte;
	bullet_y, bullet_dx, bullet_dy : byte;
	bullet_wait : byte;

	joystick_pressed : byte;
	
	

@define monster_speed "#1"


@define levelpointer "zeropage7"
@include "RasLib/Levels.ras"  

@include "RasLib/sprites.ras"  

@define playerSprite "#0"
@define bulletSprite "#7"

@define player_sprite_loc "#$90"
@define bullet_sprite_loc "#$96"

@define crashDistance "#12"

@define playerSpeed "#2"


// Updates the sprite & the sprite animation
procedure UpdatePlayerSprite();
begin
	spritepos(spritex, spritey, @playerSprite);
	sprite1_counter:=sprite1_counter-#1;
	// Animation hits at 0 and 10
	if sprite1_counter=#10 then 
		setSpriteLoc(@playerSprite, #$91, #0);

	if sprite1_counter=#0 then begin
		sprite1_counter := #20;
		setSpriteLoc(@playerSprite, #$92, #0);
	
	end;

end;

procedure PrintText();
begin
	//moveto(#2, #0, #$04);
	//printstring("HEISANN", #0, #30);
	for i:=#0 to #25 do begin
		poke($0400, i, i + #120);
		poke($0400+ #40, i, i + #160);
		poke($8400, i, i + #120);
		poke($8400+ #40, i, i + #160);
		// Color: Red
		poke($D800, i, BLUE);
		poke($D800+ #40, i, BLUE);
	end;
	moveto(#2, #24, #$D8);
	for i:=#0 to #40 do 
		pokescreen(RED, i);
	moveto(#2, #24, #$04);

	printstring("SCORE", #0, #10);

	moveto(#20, #24, #$04);

	printstring("LIFE", #0, #10);

	moveto(#30, #24, #$04);

	printstring("AMMO", #0, #10);

end;

procedure ClearText();
begin
	for i:=#0 to #25 do begin
		poke($0400, i, #$20);
		poke($0400+ #40, i, #$20);

	end;
	moveto(#0, #24, #$D8);
	for i:=#0 to #40 do 
		pokescreen(#$20, i);


end;


procedure debug(db_posx, db_posy, db_val : byte);
begin
	moveto(db_posx, db_posy, #$04);
	printnumber(db_val);
end;



procedure LoadEntities();
begin
	// levelPointer
	val:=#1;
	no_entities := #0;

	while val=#1 do begin
		// Check if entity is not zero
		if @levelpointer[#0]<>#0 then
		begin
			entity_pos_x[no_entities] := @levelpointer[#1]*#4 + #10;
			entity_pos_y[no_entities] := @levelpointer[#2]*#8+#45;
			entity_curpos_x[no_entities] := entity_pos_x[no_entities];
			entity_curpos_y[no_entities] := entity_pos_y[no_entities];
			entity_type[no_entities] := @levelpointer[#0];
			entity_color[no_entities] := @levelpointer[#4];

			entity_pos_spread[no_entities] := @levelpointer[#5];

			entity_dd_x[no_entities] := #1;
			entity_dd_y[no_entities] := #1;

			entity_framecounter_x[no_entities] := @levelpointer[#6];;
			entity_framecounter_y[no_entities] := @levelpointer[#7];;

			entity_framecounter_maxx[no_entities] := @levelpointer[#6];;
			entity_framecounter_maxy[no_entities] := @levelpointer[#7];;

			no_entities:=no_entities+#1;
			

		end
		else
			val:=#0; // break loop
		inczp(@levelpointer, m_rl_chunksize);

	end;
	debug(#15, #24, entity_pos_y[#0]);
end;


procedure InitEntities();
begin
	// Clear sprite bitmask
	poke(SPRITE_BITMASK, #0, #1);
	for val:=#0 to no_entities do begin
		i:=val+#1;
		j:=	entity_sprites[ entity_type[val] ];
		SetSpriteLoc(i, j ,#0);
		toggleBit(SPRITE_BITMASK, i, #1);
		poke(SPRITE_COLOR,i, entity_color[val]);
	end;

end;


procedure UpdateEntities();
begin

	// Move all
	
		for i:=#0 to no_entities do begin
					
			entity_framecounter_x[i]:= entity_framecounter_x[i] - #1;
			if entity_framecounter_x[i]=#0 then begin
				entity_framecounter_x[i]:=entity_framecounter_maxx[i];
				entity_curpos_x[i] := entity_curpos_x[i] + entity_dd_x[i];

				val := entity_curpos_x[i] - entity_pos_x[i];
				j:=entity_pos_spread[i];
				if val>j then
					entity_dd_x[i] := #0 - entity_dd_x[i];

			end;
	
			entity_framecounter_y[i] := entity_framecounter_y[i] - #1;
			if entity_framecounter_y[i]=#0 then begin
				entity_framecounter_y[i]:=entity_framecounter_maxy[i];
				entity_curpos_y[i] := entity_curpos_y[i] + entity_dd_y[i];

	
				val := entity_curpos_y[i] - entity_pos_y[i];
				if val>j then
					entity_dd_y[i] := #0 - entity_dd_y[i];


			end;
	end;

	for i:=#0 to no_entities do begin
		val:=i+#1;
		tmp:=entity_curpos_x[i];
		tmp:=tmp*#2;
		spritepos(tmp, entity_curpos_y[i], val );

	end;

end;


procedure InitGameOver();


procedure AbsDistance(ab_x1, ab_y1, ab_x2, ab_y2:byte);
var
	ab_tmp1, ab_tmp2: byte;
begin

	ab_tmp1 := ab_x1 - ab_x2;
	if ab_tmp1>#128 then 
		ab_tmp1:=#0 - ab_tmp1;

	ab_tmp2 := ab_y1 - ab_y2;
	if ab_tmp2>#128 then 
		ab_tmp2:=#0 - ab_tmp2;

	return := ab_tmp1 + ab_tmp2;

end; 

procedure findCollider(fc_x,fc_y:byte);
begin
	val := #255;
	j:=#0;
	for i:=#0 to no_entities do begin
		if entity_type[i]<>#0 then begin
			// Create an abs tester
			tmp2 := entity_curpos_x[i] - fc_x;
			if tmp2>#128 then 
				tmp2:=#0 - tmp2;

			k := entity_curpos_y[i] -fc_y;
			if k>#128 then 
				k:=#0 - k;

			tmp2:=tmp2 + k;
//			asm(";cras");
	//		tmp2 := AbsDistance(entity_curpos_x[i], fc_x, entity_curpos_y[i], fc_y);
			if tmp2<val then begin
				val:=tmp2;
				j:=i;
			end;
		end;
	end;
	// Winner in val, index in j

end;




procedure UpdateBullet();
begin
	val := getbit(SPRITE_BITMASK, @bulletSprite);
	//val:=#1;
	//togglebit(SPRITE_BITMASK, #7, #1);
	if val=#0 then
	begin
		tmp:=bullet_x;
		tmp:=tmp*#2;

		bullet_x := bullet_x + bullet_dx;
		bullet_y := bullet_y + bullet_dy;

		spritepos(tmp, bullet_y, @bulletSprite);


		findCollider(bullet_x, bullet_y);
		if val<#5 then begin
			togglebit(SPRITE_BITMASK, @bulletSprite, #0);
			togglebit(SPRITE_BITMASK, j+#1, #0);
			entity_type[j] :=#0; // Turn off 
			PlaySound(SID_CHANNEL3, 
				#15,  // Volume
				#5,  // Hi byte frequency 
				#0*#16+#0,  // Attack voice 1
				#5*#16 + #9,   // Sustain = 16*15 + release=6
				#1 +SID_NOISE,  // Waveform
			SID_NOISE);  // waveform

		end;
		waitnoraster(#2);
		tmp2 := getbit(SPRITE_BG_COLLISION, @bulletSprite);
		if tmp2=#0 then begin
			togglebit(SPRITE_BITMASK, @bulletSprite, #0);
//			poke(SPRITE_BITMASK, #0, #0);
		end;

		
	end;
    setSpriteLoc(#7, @bullet_sprite_loc, #0);

end;


procedure Shoot();
begin

	if (joystickbutton=#1 and (bullet_count<>#0 and bullet_wait=#0)) then begin
		// Shoot!
		bullet_x := spritex/#2;
		bullet_y := spritey;
		bullet_dy := prev_dy*#2;
		bullet_dx := prev_dx;

		bullet_x := bullet_x + bullet_dx * #4;
		bullet_y := bullet_y + bullet_dy * #4;
		togglebit(SPRITE_BITMASK, @bulletSprite, #0);

		if (bullet_dy<>#0 or bullet_dx<>#0) then begin
			tmp:=bullet_x;
			tmp:=tmp*#2;
			spritepos(tmp, bullet_y, @bulletSprite);
			togglebit(SPRITE_BITMASK, @bulletSprite, #1);
			PlaySound(SID_CHANNEL3, 
				#15,  // Volume
				#15,  // Hi byte frequency 
				#0*#16+#0,  // Attack voice 1
				#5*#16 + #6,   // Sustain = 16*15 + release=6
				#1 +SID_NOISE,  // Waveform
			SID_NOISE);  // waveform
			bullet_count:=bullet_count-#1;
			
		end;
		bullet_wait := #30;
		joystick_pressed := #0;

	end;

	if bullet_wait<>#0 then
		bullet_wait:=bullet_wait - #1;


end;







procedure UpdatePlayer();
begin
	// Update joystick routines
	Joystick();

//	if joystickbutton=#1 then
	Shoot();

	// Hit
	//val:=getBit(SPRITE_COLLISION, @playerSprite);
	tmp2:=spritex/#2;
	findCollider(tmp2, spritey);
	// returns distance
	if val<@crashDistance then begin
		val:=#0;
	end;


	if val=#0 then begin
		player_health := player_health -#1;
			PlaySound(SID_CHANNEL3, 
				#15,  // Volume
			#25,  // Hi byte frequency 
			#0*#16+#0,  // Attack voice 1
			#5*#16 + #3,   // Sustain = 16*15 + release=6
			#1 +SID_SAW,  // Waveform
			SID_NOISE);  // waveform

	end;
	if player_health = #0 then
		InitGameOver();

	// Default: don't redraw
	redraw:=#0;

	// Move sprite

	//if joystick_pressed=#0 then begin

		if (joystickright<>#0 or joystickleft<>#0) then begin
			prev_dx := joystickright - joystickleft;
			prev_dy := #0;
		end;

		if (joystickup<>#0 or joystickdown<>#0) then begin
			prev_dy := joystickdown - joystickup;
			prev_dx := #0;
		end;
		joystickdown:=joystickdown*@playerSpeed;	
		joystickup:=joystickup*@playerSpeed;	
		joystickleft:=joystickleft*@playerSpeed;	
		joystickright:=joystickright*@playerSpeed;	


		spritex:=spritex + joystickright;
		spritex:=spritex - joystickleft;
		spritey:=spritey + joystickdown - joystickup;
	//end;

	// Get sprite collision
	tmp2 := getbit(SPRITE_BG_COLLISION, @playerSprite);
	
	UpdatePlayerSprite();
	// If collision, abort abort
	if tmp2=#0 then begin
		spritex:=spritex - joystickright;
		spritex:=spritex + joystickleft;
		spritey:=spritey - joystickdown + joystickup;

	end;


	// Sprite border check
	if spritex>#318 then begin
		if m_posx<>m_rl_sizex-#1 then begin
			m_posx:=m_posx+#1;
			spritex:=#25;
			redraw:=#1;
		end
	else
		spritex:=#317;
	end;
	if spritex<#24 then begin
		if m_posx<>#0 then begin
			spritex:= #317;
			m_posx:=m_posx-#1;
			redraw:=#1;
		end
	else
		spritex:=#25;
	end;
	
	if spritey<#65 then begin
		if m_posy<>#0 then begin

			spritey:=#219;
			m_posy:=m_posy-#1;
			redraw:=#1;
		end
		else
			spritey:=#66;

	end;
	if spritey>#220 then begin
		if m_posy<>m_rl_sizey-#1 then begin
			spritey:=#66;
			m_posy:=m_posy+#1;
			redraw:=#1;
		end
		else
			spritey:=#219;
	end;
	

	if redraw=#1 then begin
    	poke(SPRITE_BITMASK,#0, #%00000000);
		ClearText();
		poke(SCREEN_FG_COL, #0, BLACK);
		// Render me baby!
		@levelpointer := levels;
		// Defined in Levels.ras
   	    RenderLevel(m_posx, m_posy, #$84);
		LoadEntities();
		InitEntities();

		current_background := peek(MULTICOLOR_CHAR_COL,#0);

		CopyFullScreen($8400, $0400);

		PrintText();
	end;


end;







procedure InitSprites();
begin

	setSpriteLoc(#0, @player_sprite_loc, #0);
	
	setSpriteLoc(#1, #$92, #0);
	
    setSpriteLoc(#2, #$93, #0);
	
    setSpriteLoc(#3, #$94, #0);

    setSpriteLoc(#4, #$95, #0);

    setSpriteLoc(#7, @bullet_sprite_loc, #0);

	poke(SPRITE_MULTICOLOR_REG1, #0, BLACK);
	poke(SPRITE_MULTICOLOR_REG2, #0, YELLOW);

    poke(SPRITE_BITMASK,#0, #%00000001);

	poke(SPRITE_COLOR,#0, RED);

	
	zeropage2:=sprite0data;
	zeropage3:=#$2400;
	CopySprites(#9);

	poke(SPRITE_MULTICOLOR, #0, #$FF); // ALL multicolor
end;




interrupt GameOverLoop();
begin
	setRegularColormode();
	poke(VIC_DATA_LOC, #0, #$1A);
	val:=val+#1;
	moveto(#15,#10, #$04);
	printstring("GAME OVER", #0, #20);
	moveto(#0,#10, #$D8);
	j:=fade[val&#15];
	for i:=#0 to #39 do
		pokescreen(j, i);




	waitForRaster(#200);
	kernelInterrupt();
end;

procedure InitGameOver();
begin
	rasterIRQ(GameOverLoop(), #1);
	for i:=#0 to #100 do begin
		poke(SPRITE_COLOR, #0, i);
		poke(SPRITE_COLOR, #1, i);
		waitForRaster(#1);
		val:=#120-i;
		PlaySound(SID_CHANNEL3, 
			#15,  // Volume
			val,  // Hi byte frequency 
			#0*#16+#0,  // Attack voice 1
			#5*#16 + #6,   // Sustain = 16*15 + release=6
			#1 +SID_NOISE,  // Waveform
			SID_SAW);  // waveform

		waitForRaster(#255);
	end;


	Setbank(VIC_BANK0);
	poke(SPRITE_BITMASK, #0, #0);
	ClearScreen(#$20, SCREEN_CHAR_LOC);
	ClearScreen(#$02, SCREEN_COL_LOC);
	poke(VIC_DATA_LOC, #0, #$1A);
	poke(SCREEN_BG_COL, #0, BLACK);

end;



interrupt rasterUpdate();
begin
	// Call sid
//	call(SIDFILE_1_PLAY);
	// Make sure upper part of screen renders text
	setRegularColorMode();
	poke(MULTICOLOR_CHAR_COL, #0, BLACK);
	waitForRaster(#1);
	// Set regular text font
	poke(VIC_DATA_LOC, #0, #$1A);
	// Wait until level starts

	waitforRaster(#67);
	// Set multi color & level font

	poke(MULTICOLOR_CHAR_COL, #0, current_background);
	poke(VIC_DATA_LOC, #0, #$1C);
	setMulticolorMode();
	moveto(#25, #24, #$04);
	printnumber(player_health);

	moveto(#35, #24, #$04);
	printnumber(bullet_count);

	UpdateBullet();
	UpdatePlayer();
	UpdateEntities();
	

	waitForRaster(#243);
	// Go back to regular font
	
	poke(MULTICOLOR_CHAR_COL, #0, BLACK);
	poke(VIC_DATA_LOC, #0, #$1A);


	waitForRaster(#255);
	// Make sure multicolor font is loaded afterwards
	poke(VIC_DATA_LOC, #0, #$1C);
		
	// Acknowledge interrupt

	kernelInterrupt();


end;


procedure Intro();
begin
	setmulticolormode();
	setbitmapmode();
	poke(VIC_DATA_LOC, #0,#$18);
	setbank(VIC_BANK2);
	copyimagecolordata(intro_image_color,#2);

	while joystickbutton<>#1 do begin
		Joystick();
		WaitForRaster(#1);
		WaitForRaster(#250);
	//	call(SIDFILE_1_PLAY);
	end;
	setTextMode();
	setbank(VIC_BANK0);

end;




begin
	
	//initsid(SIDFILE_1_INIT);
	poke(SCREEN_BG_COL, #0, #0);
	Intro();
	setmulticolormode();
	poke(VIC_DATA_LOC, #0, #$1A);

	ClearScreen(#$20, SCREEN_CHAR_LOC);
	ClearScreen(#$05 + #08, SCREEN_COL_LOC);

	ClearScreen(#$20, $8400);
	CopyFullScreen($2800, $2800 + $8000);
	CopyFullScreen($2b00, $2b00 + $8000);

	// Initial map position
	m_posx:=#0;
	m_posy:=#0;

	// Initial map rendering
	@levelpointer := levels;
	RenderLevel(m_posx, m_posy, #$04);
	current_background := peek(MULTICOLOR_CHAR_COL,#0);

	// Initial sprite position
	spritex := #160;
	spritey := #100;

	player_health := #100;

	sprite1_counter := #1;
	bullet_count :=#5;
	bullet_wait := #0;

	InitSprites();
	PrintText();

	LoadEntities();
	InitEntities();


	//setbank(VIC_BANK2);
	joystick_pressed := #0;
	frameCounter:=#0;
	// Hook that raster!
	DisableInterrupts();
	RasterIRQ(rasterUpdate(), #0);
	enableInterrupts();
	Loop();
end.
